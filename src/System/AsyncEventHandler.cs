using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace System
{
    /// <summary>
    /// Represents a method that will handle an asynchronous event.
    /// </summary>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
    /// <returns>A ValueTask that represents the handling of the event.</returns>
    public delegate ValueTask AsyncEventHandler(object? sender, EventArgs e, CancellationToken cancellationToken);

    /// <summary>
    /// Represents a method that will handle an asynchronous event with event data of type <typeparamref name="TEventArgs"/>.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
    /// <returns>A ValueTask that represents the handling of the event.</returns>
    public delegate ValueTask AsyncEventHandler<TEventArgs>(object? sender, TEventArgs e, CancellationToken cancellationToken);

    /// <summary>
    /// Provides extension methods for invoking asynchronous event handlers.
    /// </summary>
    public static class AsyncEventHandlerExtensions
    {
        #region AsyncEventHandler

        /// <summary>
        /// Invokes the specified asynchronous event handler without a cancellation token and without continuation on original context.
        /// </summary>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler. Continuations are not marshaled back to the original context captured.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync(this AsyncEventHandler? eventHandler, object? sender, EventArgs e)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext: false, continueOnException: true, CancellationToken.None);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler using the specified cancellation token and without continuation on original context.
        /// </summary>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler. Continuations are not marshaled back to the original context captured.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync(this AsyncEventHandler? eventHandler, object? sender, EventArgs e, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext: false, continueOnException: true, cancellationToken);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler without a cancellation token.
        /// </summary>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync(this AsyncEventHandler? eventHandler, object? sender, EventArgs e, bool continueOnCapturedContext)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext, continueOnException: true, CancellationToken.None);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler using the specified cancellation token and continuation context.
        /// </summary>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync(this AsyncEventHandler? eventHandler, object? sender, EventArgs e, bool continueOnCapturedContext, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext, continueOnException: true, cancellationToken);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <param name="continueOnException">Whether to continue execution if an exception occurs in one of the handlers.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">When <paramref name="continueOnException"/> is <see langword="true"/> and one or more exceptions occurred during the invocation of the event handlers.</exception>
        public static async ValueTask InvokeAsync(this AsyncEventHandler? eventHandler, object? sender, EventArgs e, bool continueOnCapturedContext, bool continueOnException, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return;

            var individualHandlers = eventHandler.GetInvocationList();
            List<Exception>? exceptions = null;
            for (var i = 0; i < individualHandlers.Length; i++)
            {
                var @delegate = individualHandlers[i];
                cancellationToken.ThrowIfCancellationRequested();
                var handler = (AsyncEventHandler)@delegate;
                try
                {
                    await handler(sender, e, cancellationToken)
                        .ConfigureAwait(continueOnCapturedContext: continueOnCapturedContext);
                }
                catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    if (!continueOnException)
                    {
                        throw;
                    }
                    exceptions ??= [];
                    exceptions.Add(ex);
                }
            }

            if (exceptions is not null)
            {
                throw new AggregateException(exceptions);
            }
        }

        #endregion

        #region AsyncEventHandler<TEventArgs>

        /// <summary>
        /// Invokes the specified asynchronous event handler without a cancellation token and without continuation on original context.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler. Continuations are not marshaled back to the original context captured.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? eventHandler, object? sender, TEventArgs e)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext: false, continueOnException: true, CancellationToken.None);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler using the specified cancellation token.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler. Continuations are not marshaled back to the original context captured.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? eventHandler, object? sender, TEventArgs e, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext: false, continueOnException: true, cancellationToken);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler without a cancellation token.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? eventHandler, object? sender, TEventArgs e, bool continueOnCapturedContext)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext, continueOnException: true, CancellationToken.None);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler using the specified cancellation token and continuation context.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">One or more exceptions occurred during the invocation of the event handlers.</exception>
        public static ValueTask InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? eventHandler, object? sender, TEventArgs e, bool continueOnCapturedContext, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return ValueTask.CompletedTask;
            return InvokeAsync(eventHandler, sender, e, continueOnCapturedContext, continueOnException: true, cancellationToken);
        }

        /// <summary>
        /// Invokes the specified asynchronous event handler with event data of type <typeparamref name="TEventArgs"/>.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to invoke.</param>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
        /// <param name="continueOnCapturedContext">Whether to marshal the continuation back to the original context captured.</param>
        /// <param name="continueOnException">Whether to continue execution if an exception occurs in one of the handlers.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the asynchronous operation.</param>
        /// <returns>A ValueTask that represents the invocation of the event handler.</returns>
        /// <exception cref="OperationCanceledException">The operation was canceled, either by the provided cancellation token or by one of the event handlers.</exception>
        /// <exception cref="AggregateException">When <paramref name="continueOnException"/> is <see langword="true"/> and one or more exceptions occurred during the invocation of the event handlers.</exception>
        public static async ValueTask InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? eventHandler, object? sender, TEventArgs e, bool continueOnCapturedContext, bool continueOnException, CancellationToken cancellationToken)
        {
            if (eventHandler is null) return;

            var individualHandlers = eventHandler.GetInvocationList();
            List<Exception>? exceptions = null;
            for (var i = 0; i < individualHandlers.Length; i++)
            {
                var @delegate = individualHandlers[i];
                cancellationToken.ThrowIfCancellationRequested();
                var handler = (AsyncEventHandler<TEventArgs>)@delegate;
                try
                {
                    await handler(sender, e, cancellationToken)
                        .ConfigureAwait(continueOnCapturedContext: continueOnCapturedContext);
                }
                catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    if (!continueOnException)
                    {
                        throw;
                    }
                    exceptions ??= [];
                    exceptions.Add(ex);
                }
            }

            if (exceptions is not null)
            {
                throw new AggregateException(exceptions);
            }
        }

        #endregion
    }
}
